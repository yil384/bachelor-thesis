\section{RQ2：Rust-for-Linux 是否达到了预期？}

在本节中，我们回顾社区在启动 RFL 时设定的初始目标（见表~\ref{tab:rfl_goals}），并围绕以下三个问题展开分析：(1) Rust 是否让 Linux 更加安全？（§~4.1）(2) Rust 是否引入额外开销？（§~4.2）(3) Rust 如何提升 Linux 开发体验？（§~4.3）

\subsection{RFL提升了Linux的可保障性（securability）}

\textbf{方法论}：我们聚焦于Rust语言在RFL及其驱动中的bug报告与unsafe代码块的使用情况。我们的基本逻辑是，RFL的安全性依赖于Rust语言的安全保障能力，而这具体取决于驱动程序中是否消除了unsafe代码块，以及是否提供了安全抽象API。因此，如果RFL存在安全漏洞，这些位置将是关键切入点。为此，我们首先收集了已合入与待合入RFL代码中的所有bug报告与与安全相关的代码审查内容（如第\ref{sec:classification}节所述），并依据RFL GitHub项目中使用的issue标签\cite{66_issue_labels_rust_2024}将bug划分为“编译类bug”与“健壮性（soundness）bug”；其中，死锁\cite{53_deadlock_bug_rfl_2024}与原子上下文中发生睡眠的并发类bug\cite{18_rfl_driver_bug_2022}被归入健壮性bug。随后，我们对上游仓库中的所有RFL驱动程序和Rust内核crate\cite{22_rust_for_linux_2022}进行了静态分析，重点统计其unsafe代码块的使用情况。

\textbf{结果}：我们共发现25个来自RFL已合入与待合入代码的bug，其中15个位于Linux主线，10个位于RFL阶段性分支，详见表~\ref{tab:bugs-in-rfl}。在已合入主线的bug中，11个为编译类bug，其余4个与安全抽象有关。前者多由内核构建配置失误、Clang工具链版本不兼容、Kbuild与rustc之间的不匹配所致\cite{17_rfl_bug_misconfig_2022}，通常不引发实际安全风险。健壮性bug中，有6个位于安全抽象层，造成内存安全破坏；3个破坏线程安全。

我们未在Linux主线中发现RFL驱动包含unsafe代码，因为截至目前，仅有一个约130行的小型驱动被合入\cite{50_rust_implementation_drivers_2023}。但我们在提交至RFL邮件列表的驱动中，发现了若干unsafe使用情况，见表~\ref{tab:unsafe-usage-drivers}。

\textbf{后续分析}：通过对上述bug与unsafe代码的审计，我们总结了以下三个关于RFL安全性的核心发现：

\textbf{启示7}：RFL确实提升了Linux的可保障性（securability），但仍无法实现完全安全（security）。

\begin{itemize}
  \item (1) Rust的安全机制构成了内核安全的支柱。该语言层的支持可帮助开发者修复现有bug并规避潜在的内存与并发问题。我们将在第5节进一步展开说明。作为一门现代语言，Rust拥有丰富的类型系统，支持如\texttt{klint}\cite{31_lints_kernel_embedded_2023}与RustBelt\cite{86_ralf_jung_rustbelt_2017}等形式化工具用于强化内核安全。相比于C语言，RFL极大压缩了由内存错误导致的攻击面，开发者在进行安全推理时的负担显著减少。
  
  \item (2) unsafe是无法避免的，尽管漏洞是可选的。我们的审计显示，所有主要驱动中普遍存在unsafe代码块，其根源在于两个方面：首先，内核需要直接控制内存与硬件，必须绕过Rust的所有权检查。例如，使用内联汇编管理TLB与发出内存屏障\cite{67_mac_gpu_driver_2024}，或解引用MMIO寄存器的裸指针等，这些操作超出了Rust所有权机制（即仿仿类型系统）的覆盖范围；其次，社区在部分API设计上不得不暂时妥协。例如，pin-init接口的内存初始化机制被Rust安全检查工具判定为unsafe，但在安全抽象层中长期存在，直到多轮资深开发者辩论后才被修复\cite{12_safe_initialization_pinned_2021,57_7_pin_init_2024,49_patch_pin_init_2023}。我们承认unsafe不等于漏洞，但它确实涉及可能的漏洞源（如MMIO），无法完全消除。

  \item (3) Bug不会消失，只是被“隐藏得更深”。一方面，被安全抽象与Rust驱动调用的内核函数仍可能存在被利用的bug；另一方面，虽然Rust编译器可以即时检测内存类bug，却无法发现语义类bug。此类bug往往源自Rust与内核在内存分配策略上的差异，难以检测，只能由精通Rust与内核的专家识别。例如，C语言实现的binder驱动存在use-after-free漏洞\cite{33_rewriting_drivers_rfl_2023}，若用Rust重写后，该漏洞不会以相同形式重现，而是转变为地址映射错误，逃过Rust编译器的所有检查。
\end{itemize}

\begin{table}[htbp]
  \centering
  \caption{RFL驱动中的unsafe使用情况统计}
  \label{tab:unsafe-usage-drivers}
  \begin{tabular}{lccc}
    \toprule
    驱动名称 & 因驱动逻辑过于复杂 & 缺乏安全抽象支持 & 总数 \\
    \midrule
    GPU\cite{67_mac_gpu_driver_2024}         & 107 & 7  & 114 \\
    NVMe\cite{69_nvme_device_driver_2024}    & 44  & 16 & 60 \\
    Null block\cite{68_null_block_driver_2024} & 0   & 0  & 0  \\
    E1000\cite{62_e1000_nic_driver_2024}      & 4   & 2  & 6  \\
    Binder\cite{59_android_binder_driver_2024} & 45  & 9  & 54 \\
    GPIO\cite{64_gpio_driver_written_2024}    & 0   & 3  & 3  \\
    Semaphore\cite{70_semaphore_driver_written_2024} & 0 & 4 & 4  \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[htbp]
  \centering
  \caption{我们在RFL中发现的bug统计（括号内为合入/阶段性代码数量）}
  \label{tab:bugs-in-rfl}
  \begin{tabular}{lcc}
    \toprule
    来源 & 编译类bug & 健壮性bug \\
    \midrule
    GitHub\cite{22_rust_for_linux_2022}     & 4(1/3) & 7(3/4) \\
    Intel LKP\cite{42_intel_linux_kernel_2023} & 8(6/2) & 0      \\
    邮件列表\cite{45_mainling_list_rust_2023} & 4(4/0) & 2(1/1) \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{RFL 是否引入额外开销？}

本节比较了 RFL 驱动与 C 语言实现的原生内核驱动，评估其性能和体积开销。我们的研究发现，Rust 驱动的可执行文件体积显著增加；其运行时性能与 C 相当，但在不同驱动与配置之间表现差异较大，波动明显。

\textbf{实验设置}：我们遍历了 RFL 的所有 Pull Request 与代码仓库，选取了 4 个具有实际应用场景的驱动，涵盖多种 IO 功能（如网络、存储），其中 NVME 与 Binder 被认为是首批合入 Linux 主线的 Rust 驱动；另外选取了 2 个 RFL 阶段性分支中的“玩具驱动”（即 gpio 与 semaphore），它们常用于探索 Rust 与 C 实现间的差异。

在这 6 个被测驱动中，仅 e1000 与两个玩具驱动实现了与 C 驱动功能一致的完整特性，其余驱动仅实现了部分功能。对于每个具有 C 对应版本的 Rust 驱动，我们分别编译二者、对比其二进制体积，并依据前人工作\cite{97_zhuohua_li_securing_2019}进行基准测试，代表其典型负载场景。表~\ref{tab:benchmarks-rfl} 展示了实验配置。

\textbf{二进制体积对比}：如图~\ref{fig:driver-size-comparison} 所示，功能完备的 Rust 驱动二进制体积明显大于 C 实现：Binder 增长 1.2 倍，Gpio 增长 2.4 倍，Semaphore 增长 1.9 倍。我们进一步分析 `.text` 段后发现，Rust 为支持泛型编程、边界检查、生命周期管理等特性而引入了 99\% 的额外代码开销。即便是仅调用内核函数的简单封装，Rust 也会将其体积扩大约 33\%。

值得注意的是，Rust 实现的 Binder 驱动体积开销相对较小，原因在于其广泛使用了带 \texttt{unsafe} 的函数指针而非泛型编程，从而在一定程度上牺牲了 RFL 设计初衷中的安全性。

虽然部署前一般会剥离调试信息，但在嵌入式系统中资源有限，调试模式下的开销亦不容忽视。我们将在附录 §B 中进一步讨论。

\textbf{性能表现}：总体来看，Rust 驱动与 C 驱动性能大致相当，差距在 20\% 范围内。但部分场景中，Rust 明显逊色；而在另一些配置下，Rust 表现反而优于 C。

具体分析如下：

\begin{itemize}
  \item 对于 \texttt{e1000}，Rust 驱动在 ping 延迟测试中性能是 C 驱动的 11 倍\textbf{慢}，如图~\ref{fig:e1000-latency} 所示。主要原因在于 Rust 驱动未实现如预取（prefetch）等加速特性。
  \item 对于 \texttt{binder}，Rust 与 C 在 ping 延迟上表现相近，仅有 10\% 性能差距。
  \item 对于存储驱动（如 \texttt{NVME} 与 \texttt{NULL block}），Rust 驱动在不同配置下出现了最高 61\% 的性能下降，也有最多 67\% 的性能提升，如图~\ref{fig:nullblock-comparison} 与图~\ref{fig:nvme-comparison} 所示。我们观察到 Rust 驱动更适应较小任务数与 block size，这可能与 Rust 结构体尺寸更小、更易适配缓存行有关。
\end{itemize}

为了进一步分析相同行为路径下 Rust 与 C 驱动性能差异的根因，我们利用 \texttt{vtune} 与 \texttt{ftrace} 等内核工具开展微基准测试。总结如下：

\textbf{为何 Rust 驱动可能表现更差？}
\begin{itemize}
  \item Rust 驱动的锁粒度较粗。虽然 Rust 通过语言规则保障线程安全，但高性能并发编程仍需开发者手动调优。
  \item Rust 的数组访问引入了边界检查，增加运行时开销，与已有研究结果一致，后者指出 Rust 程序在内存密集型场景下开销可能高达 C 的 2.49 倍\cite{110_yuchen_zhang_towards_2023}。
  \item Rust 采用模拟位域方式访问字段（见第 \ref{sec:bitfield} 节），结合运行时检查进一步拖慢执行速度。
  \item Rust 广泛使用智能指针共享所有权，导致缓存/TLB/分支预测失效率上升。
\end{itemize}

\textbf{为何 Rust 驱动可能表现更好？}
\begin{itemize}
  \item Rust 结构体通常比 C 更小，因其使用智能指针而非直接在结构体中分配字段内存。使用 \texttt{pahole} 工具可发现，Rust 结构体更节省缓存行。
  \item 某些 Rust 驱动未实现全部功能，导致部分代码路径被省略。
\end{itemize}

\textbf{启示8}：性能从来不是免费的——程序员的实现才是决定性因素！

\begin{table}[htbp]
  \centering
  \caption{测试 Rust/C 驱动的基准任务与指标（PC 配置：Intel i5-4590/4核，Q87主板，32GB DDR3，Samsung SSD 850 Evo，WD SN770，Intel 82545 网卡）}
  \label{tab:benchmarks-rfl}
  \begin{tabular}{lccc}
    \toprule
    驱动 & 基准工具 & 测量指标 & 测试设备 \\
    \midrule
    NVME         & fio  & 吞吐量、驱动体积 & PC \\
    Null Block   & fio  & 吞吐量             & PC \\
    E1000        & ping & 延迟               & PC \\
    Binder       & ping & 延迟               & Raspberry Pi 4B \\
    Gpio\_pl061  & -    & -                 & - \\
    Semaphore    & -    & -                 & - \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\linewidth]{driver_size_comparison.jpg}
  \caption{Rust 与 C 驱动的体积比较。带 * 的表示 Rust 驱动未实现完整功能}
  \label{fig:driver-size-comparison}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\linewidth]{e1000_latency.jpg}
  \caption{Rust 与 C 驱动延迟对比，e1000 驱动因缺失优化特性（如预取）性能落后}
  \label{fig:e1000-latency}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\linewidth]{nullblock_perf.jpg}
  \caption{NULL block 驱动性能对比。绿色表示 Rust 表现更优，红色表示劣于 C}
  \label{fig:nullblock-comparison}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\linewidth]{nvme_perf.jpg}
  \caption{NVME 驱动性能对比}
  \label{fig:nvme-comparison}
\end{figure}

\subsection{Rust 如何改善 Linux 的开发？}

本节展示了 Rust 在提升内核代码质量、可读性以及吸引新开发者参与方面的显著作用。

\textbf{代码质量与可读性的提升}：我们采用文档覆盖率与每千行代码的持续集成（CI）错误数作为衡量软件质量的两个关键指标\cite{76_vikas_chomal_significance_2014,106_jorge_wong-mozqueda_code_2015}。

在文档覆盖率方面，我们统计了通过 \texttt{EXPORT\_SYMBOL} 与 \texttt{EXPORT\_SYMBOL\_GPL} 导出的 API；根据内核文档规范\cite{43_linux_kernel_docuement_2023}，这些 API 应当全部配有文档。在 CI 错误方面，我们收集了来自 Intel LKP、Syzbot\cite{41_google_syzbot_kernel_2023} 与 KernelCI\cite{38_community_based_distributed_2023} 的相关报告。

我们将 RFL 与两个近年来发展迅速的内核子系统 eBPF 与 io\_uring 进行了比较。结果如表~\ref{tab:code-quality-metrics} 所示，RFL 在代码文档覆盖率方面表现优异（100\%），而 eBPF 与 io\_uring 仅分别为 15\% 与 31\%。在每万行代码的 CI 错误数方面，RFL 也远低于其他两个子系统，分别减少了 49\% 与 68\%。

造成这一改善的原因主要有两点：

首先，RFL 利用了 Rust 的 \texttt{rustdoc lints} 功能，强制要求为所有（或部分）接口撰写文档。相比之下，传统内核开发主要依赖默认约定或人工审查，导致文档常被省略\cite{4_linus_explained_docuementation_2015}。例如，\texttt{io\_uring\_cmd\_complete\_in\_task} 是 io\_uring 中通过 \texttt{EXPORT\_SYMBOL\_GPL} 导出的关键函数，用于在工作线程中异步完成 IO 操作，但由于缺乏文档，开发者常将其与 \texttt{io\_uring\_cmd\_done} 混淆，进而引发 AB-BA 死锁\cite{30_fix_ab_ba_2023}。事实上，社区早已将“文档缺失”视为 Linux 中的第一号 bug\cite{2_carla_schroder_missing_2009}。

其次，Rust 内建的测试机制允许开发者在提交 PR 之前便运行测试。相比之下，现有的 Linux 内核测试框架（如 KUnit\cite{26_unit_testing_framework_2023} 与 Intel LKP\cite{42_intel_linux_kernel_2023}）通常在代码合入或临近合入阶段才被触发。而在 RFL 中，测试代码可通过 \texttt{\#cfg(test)} 注解集成，结合 GitHub CI，可在每次 PR 提交时自动运行。正是由于测试环节提前介入，使得 RFL 的 CI 错误显著减少，代码质量也随之提升。

\textbf{更多“新鲜血液”参与 Linux 社区开发}：我们进一步比较了 RFL 与 eBPF、io\_uring 以及传统子系统 netdev 的开发者构成。受到 netdev 相关研究启发\cite{52_time_since_first_2023}，我们使用开发者首次 commit 的时间跨度作为经验指标，将开发者划分为新手（0--24 个月）、熟练开发者（24--120 个月）与资深开发者（120 个月以上）。

采样区间为 Linux 版本 6.1 至 6.4。结果如图~\ref{fig:developer-experience-dist} 所示，RFL 拥有最高比例的新手开发者（58\%），显著高于 eBPF（39\%）、io\_uring（38\%）与 netdev（29\%）。更有趣的是，我们发现其中有 29 位开发者此前从未向 Linux 提交过一行 C 代码。这表明，Rust 很可能是吸引他们进入内核社区的主要动因，打破了长期以来内核开发以 C 为中心的格局。

\textbf{然而，这些新手开发者尚未成为核心开发者或维护者}：尽管有更多新手被 Rust 吸引进入 Linux 社区，我们发现他们的贡献主要集中在 Rust 工具链或 crate 的构建上，并未实质参与内核功能开发。相较之下，第~\ref{tab:benchmarks-rfl} 表中列出的 6 个驱动中，有 5 个主要由传统 Linux 社区的资深开发者完成。这说明年轻开发者与资深开发者之间仍存在断层，Rust 语言虽提升了吸引力，但并未真正降低内核开发的门槛。

\begin{table}[htbp]
  \centering
  \caption{代码质量测量结果。文档覆盖率以 \% 表示，CI 错误数按每 1 万行代码统计}
  \label{tab:code-quality-metrics}
  \begin{tabular}{lcc}
    \toprule
    子系统     & 文档覆盖率（\%） & CI 错误数/10K LoC \\
    \midrule
    RFL        & 100\%   & 3.8 \\
    eBPF       & 15\%    & 7.5 \\
    io\_uring  & 31\%    & 11.9 \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\linewidth]{developer_experience_distribution.jpg}
  \caption{RFL 与其他主流内核子系统的开发者经验分布。RFL 拥有最高比例的新手开发者}
  \label{fig:developer-experience-dist}
\end{figure}

